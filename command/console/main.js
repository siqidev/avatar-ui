// 画面の主要要素をまとめて取得。
const outputEl = document.getElementById('output');
const inputEl = document.getElementById('input');
const avatarImg = document.getElementById('avatar-img');
const metaBar = document.getElementById('meta');
const avatarLabel = document.getElementById('avatar-label');
const terminalSurface = document.getElementById('terminal-surface');
const terminalHost = document.getElementById('terminal-host');
const commandPaletteEl = document.getElementById('command-palette');
const missionPurposeEl = document.getElementById('mission-purpose');
const missionGoalsEl = document.getElementById('mission-goals');
const inspectorTimelineEl = document.getElementById('inspector-timeline');
const vitalsCpuEl = document.getElementById('vitals-cpu');
const vitalsCpuBarEl = document.getElementById('vitals-cpu-bar');
const vitalsMemoryEl = document.getElementById('vitals-memory');
const vitalsMemoryBarEl = document.getElementById('vitals-memory-bar');
const vitalsNetworkEl = document.getElementById('vitals-network');
const vitalsNetworkBarEl = document.getElementById('vitals-network-bar');
const vitalsApiEl = document.getElementById('vitals-api');
const vitalsApiBarEl = document.getElementById('vitals-api-bar');

if (!outputEl || !inputEl || !avatarImg || !metaBar || !avatarLabel || !terminalSurface || !terminalHost || !commandPaletteEl || !missionPurposeEl || !missionGoalsEl) {
  throw new Error('UI elements missing');
}

// 会話セッションIDはブラウザに保存し、次回も同じ文脈を使えるようにする。
const idleSrc = avatarImg?.dataset?.idle;
const talkSrc = avatarImg?.dataset?.talk;
if (!idleSrc || !talkSrc) {
  throw new Error('Avatar data attributes are missing');
}
const sessionKey = 'spectra-session-id';
const storedSessionId = window.localStorage.getItem(sessionKey);
const sessionId = storedSessionId || crypto.randomUUID();
if (!storedSessionId) {
  window.localStorage.setItem(sessionKey, sessionId);
}

inputEl.disabled = true;

// 画面に1行追加し、自動でスクロールする。
const addLine = (className, text) => {
  const line = document.createElement('div');
  line.className = `text-line ${className}`.trim();
  line.textContent = text;
  outputEl.appendChild(line);
  outputEl.scrollTop = outputEl.scrollHeight;
};

// 応答中だけアバター画像を切り替える。
const setTalking = (isTalking) => {
  avatarImg.src = isTalking ? talkSrc : idleSrc;
};

const failFast = (message) => {
  isFatal = true;
  addLine('text-line--error', `ERROR> ${message}`);
  inputEl.disabled = true;
  throw new Error(message);
};

let consoleConfig = null;
let adminConfig = null;
let isFatal = false;
let commandState = null;
let pendingApproval = null;
let terminalCapture = null;

const requireSpectraApi = () => {
  if (!window.spectraApi) {
    failFast('spectraApi is not available');
  }
  return window.spectraApi;
};

// 端末APIが無ければ即停止する。
const requireTerminalApi = () => {
  if (!window.spectraTerminal) {
    failFast('spectraTerminal is not available');
  }
  return window.spectraTerminal;
};

// 管理APIが無ければ即停止する。
const requireAdminApi = () => {
  const api = requireSpectraApi();
  if (!api.getAdminConfig || !api.updateAdminConfig) {
    failFast('Admin config API is not available');
  }
  return api;
};

// 観測APIが無ければ即停止する。
const requireObservationApi = () => {
  const api = requireSpectraApi();
  if (!api.sendObservation) {
    failFast('Observation API is not available');
  }
  return api;
};

// 取得したConsole設定をCSS変数と表示に反映する。
const applyConsoleConfig = (data) => {
  if (!data) {
    failFast('Console config is missing.');
  }
  const root = document.documentElement;
  const ui = data.console_ui;
  if (!ui) {
    failFast('console_ui is missing.');
  }

  const hexToRgb = (hex) => {
    if (typeof hex !== 'string') {
      return null;
    }
    const match = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (!match) {
      return null;
    }
    return {
      r: parseInt(match[1], 16),
      g: parseInt(match[2], 16),
      b: parseInt(match[3], 16),
    };
  };

  const setRgb = (key, value) => {
    const rgb = hexToRgb(value);
    if (!rgb) {
      failFast(`console_ui.${key.replace('-', '_')} is invalid.`);
    }
    root.style.setProperty(`--${key}-r`, String(rgb.r));
    root.style.setProperty(`--${key}-g`, String(rgb.g));
    root.style.setProperty(`--${key}-b`, String(rgb.b));
  };

  setRgb('theme-color', ui.theme_color);
  setRgb('user-color', ui.user_color);
  setRgb('tool-color', ui.tool_color);

  if (ui.opacity !== undefined) {
    root.style.setProperty('--ui-opacity', String(ui.opacity));
  }
  if (ui.brightness !== undefined) {
    root.style.setProperty('--ui-brightness', String(ui.brightness));
  }
  if (ui.glow_text !== undefined) {
    root.style.setProperty('--glow-text-alpha1', String(0.6 * ui.glow_text));
    root.style.setProperty('--glow-text-alpha2', String(0.4 * ui.glow_text));
  }
  if (ui.glow_box !== undefined) {
    root.style.setProperty('--glow-box-alpha1', String(0.4 * ui.glow_box));
    root.style.setProperty('--glow-box-alpha2', String(0.2 * ui.glow_box));
  }
  if (ui.avatar_overlay_opacity !== undefined) {
    root.style.setProperty('--avatar-overlay-opacity', String(ui.avatar_overlay_opacity));
  }
  if (ui.avatar_brightness !== undefined) {
    root.style.setProperty('--avatar-brightness', String(ui.avatar_brightness));
  }

  if (!ui.name_tags?.avatar) {
    failFast('console_ui.name_tags.avatar is missing.');
  }
  avatarLabel.textContent = ui.name_tags.avatar;

  if (!ui.system_messages?.banner1 || !ui.system_messages?.banner2) {
    failFast('console_ui.system_messages is missing.');
  }
  addLine('text-line--system', `> ${ui.system_messages.banner1}`);
  addLine('text-line--system', `> ${ui.system_messages.banner2}`);

  if (!ui.command_palette?.commands || !ui.command_palette?.options) {
    failFast('console_ui.command_palette is missing.');
  }

  consoleConfig = ui;
};

// CoreからConsole設定を取得する。
const loadConsoleConfig = async () => {
  const api = requireSpectraApi();
  if (!api.getConsoleConfig) {
    throw new Error('getConsoleConfig is not available');
  }
  return api.getConsoleConfig();
};

// 最後に処理したイベントの時刻。
let lastEventTime = null;
// 初回ポーリングフラグ（過去イベントをスキップ）。
let isFirstPoll = true;

// イベントをポーリングしてdialogueに表示する。
const pollEvents = async () => {
  const api = requireSpectraApi();
  if (!api.getRecentEvents) {
    return;
  }
  try {
    const data = await api.getRecentEvents(lastEventTime);
    const events = data?.events || [];
    for (const event of events) {
      // 時刻を更新。
      if (event.time) {
        lastEventTime = event.time;
      }
      // 初回は時刻同期のみ（過去イベントは表示しない）。
      if (isFirstPoll) {
        continue;
      }
      // outputイベントをdialogueに表示。
      if (event.type === 'output' && event.pane === 'dialogue') {
        addLine('text-line--avatar', event.text);
      }
    }
    isFirstPoll = false;
    // イベントがあればペインも更新。
    if (events.length > 0 && !isFirstPoll) {
      updateMissionPane();
      updateInspectorPane();
    }
  } catch (error) {
    // ポーリングエラーは静かに無視。
  }
};

// Missionペインを更新する。
const updateMissionPane = async () => {
  const api = requireSpectraApi();
  if (!api.getState) {
    return;
  }
  try {
    const state = await api.getState();
    const mission = state?.mission || {};

    // Purpose表示
    const purpose = mission.purpose || '(none)';
    missionPurposeEl.textContent = `Purpose: ${purpose}`;

    // Goals表示
    const goals = mission.goals || [];
    missionGoalsEl.innerHTML = '';

    // 全体進捗を計算
    let totalDone = 0;
    let totalTasks = 0;
    goals.forEach((g) => {
      const tasks = g.tasks || [];
      totalTasks += tasks.length;
      totalDone += tasks.filter((t) => t.status === 'done').length;
    });
    const totalRate = totalTasks > 0 ? Math.round((totalDone / totalTasks) * 100) : 0;

    // 全体進捗バーを更新
    const barFill = document.getElementById('mission-bar-fill');
    const summaryRate = document.getElementById('mission-summary-rate');
    if (barFill) {
      barFill.style.width = `${totalRate}%`;
    }
    if (summaryRate) {
      summaryRate.textContent = `[${totalDone}/${totalTasks}, ${totalRate}%]`;
    }

    if (goals.length === 0) {
      const noGoals = document.createElement('div');
      noGoals.className = 'mission-goal';
      noGoals.textContent = '(no goals)';
      missionGoalsEl.appendChild(noGoals);
      return;
    }

    goals.forEach((goal) => {
      const goalEl = document.createElement('div');
      goalEl.className = 'mission-goal';

      const tasks = goal.tasks || [];
      const doneCount = tasks.filter((t) => t.status === 'done').length;
      const totalCount = tasks.length;
      const rate = totalCount > 0 ? Math.round((doneCount / totalCount) * 100) : 0;

      // Goal header
      const header = document.createElement('div');
      header.className = 'mission-goal-header';

      const toggle = document.createElement('span');
      toggle.className = 'mission-goal-toggle';
      toggle.textContent = '▼';

      const goalId = document.createElement('span');
      goalId.className = 'mission-goal-id';
      goalId.textContent = goal.id;

      const goalName = document.createElement('span');
      goalName.className = 'mission-goal-name';
      goalName.textContent = goal.name;

      const goalRate = document.createElement('span');
      goalRate.className = 'mission-goal-rate';
      goalRate.textContent = `[${doneCount}/${totalCount}, ${rate}%]`;

      header.appendChild(toggle);
      header.appendChild(goalId);
      header.appendChild(goalName);
      header.appendChild(goalRate);
      goalEl.appendChild(header);

      // Tasks
      const tasksEl = document.createElement('div');
      tasksEl.className = 'mission-tasks';

      tasks.forEach((task) => {
        const taskEl = document.createElement('div');
        taskEl.className = 'mission-task';

        const icon = document.createElement('span');
        icon.className = `mission-task-icon mission-task-icon--${task.status}`;
        if (task.status === 'done') {
          icon.textContent = '✓';
        } else if (task.status === 'active') {
          icon.textContent = '●';
        } else if (task.status === 'fail') {
          icon.textContent = '✗';
        } else {
          icon.textContent = '○';
        }

        const taskId = document.createElement('span');
        taskId.className = 'mission-task-id';
        taskId.textContent = task.id;

        const taskName = document.createElement('span');
        taskName.className = 'mission-task-name';
        taskName.textContent = task.name;

        const taskStatus = document.createElement('span');
        taskStatus.className = 'mission-task-status';
        // active/pending はラベル表示、done/failは表示しない
        if (task.status === 'active' || task.status === 'pending') {
          taskStatus.textContent = `(${task.status})`;
        }

        taskEl.appendChild(icon);
        taskEl.appendChild(taskId);
        taskEl.appendChild(taskName);
        taskEl.appendChild(taskStatus);
        tasksEl.appendChild(taskEl);
      });

      goalEl.appendChild(tasksEl);

      // Toggle click handler
      header.addEventListener('click', () => {
        const isCollapsed = tasksEl.classList.toggle('is-collapsed');
        toggle.textContent = isCollapsed ? '▶' : '▼';
      });

      missionGoalsEl.appendChild(goalEl);
    });
  } catch (error) {
    console.error('Failed to update mission pane:', error);
  }
};

// Inspectorタイムラインに表示済みのイベントIDを追跡
let inspectorDisplayedEvents = new Set();
const INSPECTOR_MAX_ENTRIES = 10;

// Inspectorタイムラインにエントリを追加する（THINKのみ、2行表示）。
const addInspectorEntry = (text, isNew = true) => {
  if (!inspectorTimelineEl) return;

  // 「タスク：」「目標設定:」などのプレフィックスを除去
  const cleanText = text
    .replace(/^(タスク|目標|目標設定|判断|意図)[：:]\s*/gi, '')
    .trim();

  if (!cleanText) return;

  // 重複チェック（同じテキストが直前にあればスキップ）
  const firstChild = inspectorTimelineEl.firstElementChild;
  if (firstChild) {
    const existingText = firstChild.querySelector('.inspector-entry-text')?.textContent;
    if (existingText === cleanText) return;
  }

  // 既存のis-latestを削除
  inspectorTimelineEl.querySelectorAll('.is-latest').forEach((el) => {
    el.classList.remove('is-latest');
  });

  // 2行（約50文字）を超えるかどうかの判定
  const hasMore = cleanText.length > 50;

  // 新しいエントリを作成
  const entry = document.createElement('div');
  entry.className = `inspector-entry is-latest${isNew ? ' is-new' : ''}${hasMore ? ' has-more' : ''}`;

  // プロンプトとテキストを同じ行に
  const lineEl = document.createElement('div');
  lineEl.className = 'inspector-entry-line';

  const promptEl = document.createElement('span');
  promptEl.className = 'inspector-entry-prompt';
  promptEl.textContent = '>';

  const textEl = document.createElement('span');
  textEl.className = 'inspector-entry-text';
  textEl.textContent = cleanText;

  lineEl.appendChild(promptEl);
  lineEl.appendChild(textEl);
  entry.appendChild(lineEl);

  // クリックで展開/折りたたみ
  entry.addEventListener('click', () => {
    if (hasMore) {
      entry.classList.toggle('is-expanded');
    }
  });

  // 先頭に追加
  inspectorTimelineEl.insertBefore(entry, inspectorTimelineEl.firstChild);

  // アニメーション後にis-newを削除
  if (isNew) {
    setTimeout(() => entry.classList.remove('is-new'), 400);
  }

  // 最大数を超えたら古いエントリを削除
  while (inspectorTimelineEl.children.length > INSPECTOR_MAX_ENTRIES) {
    inspectorTimelineEl.removeChild(inspectorTimelineEl.lastChild);
  }
};

// Inspectorペインを更新する（イベントベース）。
const updateInspectorPane = async () => {
  const api = requireSpectraApi();
  if (!api.getState || !api.getRecentEvents) {
    return;
  }
  try {
    const state = await api.getState();
    const action = state?.action;

    // 自律ループからの承認待ちを検知（未処理の場合のみ）
    // approving のみ処理（awaiting_continue, awaiting_purpose_confirm は別処理）
    if (action?.phase === 'approving' && action?.command && !pendingApproval && !pendingContinue) {
      requestApproval('__terminal__', action.command, action.summary || action.command);
    }

    // 最近のイベントを取得してタイムラインに追加
    const data = await api.getRecentEvents();
    const events = data?.events || [];
    if (events.length === 0) return;

    // 新しいイベントを古い順に処理（タイムラインの先頭に追加するため）
    const newEvents = events.filter((e) => !inspectorDisplayedEvents.has(e.time + e.type));
    
    // 古い順にソート
    newEvents.sort((a, b) => new Date(a.time) - new Date(b.time));

    for (const event of newEvents) {
      const eventId = event.time + event.type;
      inspectorDisplayedEvents.add(eventId);

      // THINKのみ表示（ACT/DONEはDialogueに表示されるため）
      if (event.type === 'thought') {
        const text = event.judgment || event.intent || '-';
        addInspectorEntry(text);
      }
      // action, result は無視（Dialogueで表示）
    }
  } catch (error) {
    console.error('Failed to update inspector pane:', error);
  }
};

// Vitalsペインを更新する（現在はモックデータ）。
const updateVitalsPane = () => {
  // TODO: 実際のシステム情報を取得する（Electron IPC経由）
  // 現在はモックデータを表示
  const mockData = {
    cpu: { value: 23, unit: '%', max: 100 },
    memory: { value: 4.2, unit: 'GB', max: 16 },
    network: { value: 12, unit: 'Mbps', max: 100 },
    api: { value: 34, unit: '%', max: 100 },
  };

  if (vitalsCpuEl && vitalsCpuBarEl) {
    vitalsCpuEl.textContent = `${mockData.cpu.value}${mockData.cpu.unit}`;
    vitalsCpuBarEl.style.width = `${(mockData.cpu.value / mockData.cpu.max) * 100}%`;
  }
  if (vitalsMemoryEl && vitalsMemoryBarEl) {
    vitalsMemoryEl.textContent = `${mockData.memory.value}${mockData.memory.unit}`;
    vitalsMemoryBarEl.style.width = `${(mockData.memory.value / mockData.memory.max) * 100}%`;
  }
  if (vitalsNetworkEl && vitalsNetworkBarEl) {
    vitalsNetworkEl.textContent = `${mockData.network.value}${mockData.network.unit}`;
    vitalsNetworkBarEl.style.width = `${(mockData.network.value / mockData.network.max) * 100}%`;
  }
  if (vitalsApiEl && vitalsApiBarEl) {
    vitalsApiEl.textContent = `${mockData.api.value}${mockData.api.unit}`;
    vitalsApiBarEl.style.width = `${(mockData.api.value / mockData.api.max) * 100}%`;
  }
};

// 製品名とバージョンをUIに表示する。
const startUi = () => {
  const api = requireSpectraApi();
  if (!api.getAppInfo) {
    failFast('getAppInfo is not available');
  }
  const appInfo = api.getAppInfo();
  if (!appInfo?.name || !appInfo?.version) {
    failFast('App metadata is missing.');
  }
  metaBar.textContent = `${appInfo.name} v${appInfo.version}`;
};

// xtermを初期化して端末を接続する。
const setupTerminal = () => {
  const terminalApi = requireTerminalApi();
  if (!window.Terminal) {
    failFast('xterm is not available');
  }
  const fitFactory = window.FitAddon?.FitAddon;
  if (!fitFactory) {
    failFast('xterm-addon-fit is not available');
  }

  const terminal = new window.Terminal({
    fontFamily: 'Consolas, Menlo, monospace',
    cursorBlink: true,
    theme: {
      background: 'transparent',
      foreground: 'rgba(220, 255, 240, 0.95)',
    },
  });
  const fitAddon = new fitFactory();
  terminal.loadAddon(fitAddon);
  terminal.open(terminalHost);
  fitAddon.fit();

  terminalApi.create(terminal.cols, terminal.rows).catch((error) => {
    failFast(error instanceof Error ? error.message : String(error));
  });
  terminalApi.onData((data) => {
    terminal.write(data);
    if (terminalCapture) {
      terminalCapture.buffer += data;
      if (terminalCapture.buffer.length > terminalCapture.maxBytes) {
        terminalCapture.buffer = terminalCapture.buffer.slice(0, terminalCapture.maxBytes);
        terminalCapture.truncated = true;
      }
      clearTimeout(terminalCapture.timer);
      terminalCapture.timer = setTimeout(() => {
        terminalCapture.finish();
      }, terminalCapture.idleMs);
    }
  });
  terminal.onData((data) => {
    terminalApi.write(data);
  });

  const resizeTerminal = () => {
    fitAddon.fit();
    terminalApi.resize(terminal.cols, terminal.rows);
  };
  window.addEventListener('resize', resizeTerminal);
  terminal.focus();

  // ANSIエスケープを除去して読みやすくする。
  const stripAnsi = (value) => value.replace(/\u001b\[[0-9;]*[A-Za-z]/g, '').replace(/\u001b\][^\u0007]*\u0007/g, '');

  // ターミナル実行の出力を一定時間だけ集めて確認する。
  const runCommand = (command) => {
    if (terminalCapture) {
      failFast('Terminal is busy');
    }
    const maxBytes = 2000;
    const idleMs = 800;
    return new Promise((resolve) => {
      terminalCapture = {
        buffer: '',
        maxBytes,
        idleMs,
        truncated: false,
        timer: null,
        finish: () => {
          const result = terminalCapture;
          terminalCapture = null;
          resolve(result);
        },
      };
      terminalApi.write(`${command}\r`);
    });
  };

  // 提案されたターミナル操作を実行し、結果をコアに渡す。
  window.runTerminalCommand = (command, label) => {
    addLine('text-line--system', `> run ${label}`);
    const api = requireSpectraApi();
    runCommand(command)
      .then((result) => {
        const cleaned = stripAnsi(result.buffer).trimEnd();
        const suffix = result.truncated ? '\n... (truncated)' : '';
        const content = cleaned + suffix;

        // 観測結果を送信。
        const observationPromise = content
          ? api.sendObservation({ session_id: sessionId, content })
          : Promise.resolve();

        // タスク完了を通知。
        return observationPromise.then(() => {
          return api.completeAction({ success: true, summary: label });
        });
      })
      .then(() => {
        addLine('text-line--system', `> done ${label}`);
        // ペインを更新。
        updateMissionPane();
        updateInspectorPane();
      })
      .catch((error) => {
        // 失敗時も完了通知を送る。
        api.completeAction({ success: false, summary: error.message }).catch(() => {});
        failFast(error instanceof Error ? error.message : String(error));
      });
  };
};

// 管理用の設定を読み込み、コマンドに使う。
const loadAdminConfig = async () => {
  const api = requireAdminApi();
  return api.getAdminConfig();
};

// ターミナル提案を実行する。
const runTerminalProposal = (command, label) => {
  if (!window.runTerminalCommand) {
    failFast('Terminal runner is not available');
  }
  window.runTerminalCommand(command, label);
};

// コマンド候補の表示を制御する。
const showPalette = () => {
  commandPaletteEl.classList.remove('is-hidden');
};

const hidePalette = () => {
  commandPaletteEl.classList.add('is-hidden');
  commandPaletteEl.innerHTML = '';
};

const renderPalette = (items, activeIndex) => {
  commandPaletteEl.innerHTML = '';
  items.forEach((item, index) => {
    const row = document.createElement('div');
    row.className = `command-item${index === activeIndex ? ' is-active' : ''}`;
    row.dataset.value = item.value ?? '';
    row.dataset.commandId = item.commandId ?? '';
    row.innerHTML = `
      <span class="command-label">${item.label}</span>
      <span class="command-desc">${item.description ?? ''}</span>
    `.trim();
    commandPaletteEl.appendChild(row);
  });
  if (items.length === 0) {
    hidePalette();
    return;
  }
  showPalette();
};

const resetCommandState = () => {
  commandState = null;
  hidePalette();
};

// 承認が必要な操作を記録する。
const requestApproval = (commandId, value, label) => {
  pendingApproval = { commandId, value, label };
  addLine('text-line--system', `> approve ${label}? (y/n)`);
  inputEl.value = '';
  hidePalette();
};

// 空入力時に awaiting_continue なら続行する。
const handleEmptyContinue = async () => {
  const api = requireSpectraApi();
  try {
    const state = await api.getState();
    if (state?.action?.phase === 'awaiting_continue') {
      api.continueLoop()
        .then(() => {
          addLine('text-line--system', '> 続行');
          updateMissionPane();
          updateInspectorPane();
        })
        .catch((error) => {
          console.error('Continue failed:', error);
        });
    }
  } catch (error) {
    console.error('Failed to check continue state:', error);
  }
};

// 承認入力を処理する。
const handleApprovalInput = () => {
  if (!pendingApproval) {
    return false;
  }
  const answer = inputEl.value.trim().toLowerCase();
  if (answer !== 'y' && answer !== 'n') {
    addLine('text-line--system', '> type y or n');
    inputEl.value = '';
    return true;
  }
  const action = pendingApproval;
  pendingApproval = null;
  inputEl.value = '';
  if (answer === 'n') {
    addLine('text-line--system', `> canceled ${action.label}`);
    return true;
  }
  // 承認処理
  const api = requireSpectraApi();

  // リセットは特別処理（Coreへの承認通知不要）
  if (action.commandId === '__reset__') {
    api.resetState()
      .then(() => {
        addLine('text-line--system', '> 状態がリセットされました');
        updateMissionPane();
        updateInspectorPane();
        inputEl.focus();
      })
      .catch((error) => {
        failFast(error instanceof Error ? error.message : String(error));
      });
    return true;
  }

  // 続行確認は特別処理
  if (action.commandId === '__continue__') {
    api.continueLoop()
      .then(() => {
        addLine('text-line--system', '> 続行');
        updateMissionPane();
        updateInspectorPane();
        inputEl.focus();
      })
      .catch((error) => {
        failFast(error instanceof Error ? error.message : String(error));
      });
    return true;
  }

  // 通常の承認をCoreに通知してからコマンドを実行。
  api.approveAction()
    .then(() => {
      if (action.commandId === '__terminal__') {
        runTerminalProposal(action.value, action.label);
      } else {
        applyAdminUpdate(action.commandId, action.value)
          .then(() => {
            inputEl.focus();
          })
          .catch((error) => {
            failFast(error instanceof Error ? error.message : String(error));
          });
      }
    })
    .catch((error) => {
      failFast(error instanceof Error ? error.message : String(error));
    });
  return true;
};

// コマンドを選ぶ画面を表示する。
const openCommandPalette = (filterText) => {
  if (!consoleConfig?.command_palette?.commands) {
    failFast('Command palette config is missing.');
  }
  const keyword = filterText.toLowerCase();
  const items = consoleConfig.command_palette.commands
    .filter((cmd) => cmd.label.toLowerCase().startsWith(`/${keyword}`))
    .map((cmd) => ({
      label: cmd.label,
      description: cmd.description,
      commandId: cmd.id,
    }));
  commandState = { type: 'commands', items, activeIndex: 0 };
  renderPalette(items, 0);
};

// 選んだコマンドの値を選択する。
const openCommandOptions = (commandId) => {
  // /reset は特別処理: 警告を出して確認を求める
  if (commandId === 'reset') {
    requestApproval('__reset__', null, '⚠️ 全ての状態（目的・目標・タスク）をリセット');
    resetCommandState();
    return;
  }

  const options = consoleConfig?.command_palette?.options?.[commandId];
  if (!options) {
    commandState = { type: 'value', commandId };
    hidePalette();
    inputEl.value = '';
    inputEl.placeholder = `${commandId} value`;
    return;
  }
  const items = options.map((entry) => {
    if (entry && typeof entry === 'object') {
      return {
        label: entry.label ?? String(entry.value ?? ''),
        description: 'select value',
        value: entry.value,
        commandId,
      };
    }
    return {
      label: String(entry),
      description: 'select value',
      value: entry,
      commandId,
    };
  });
  commandState = { type: 'options', items, activeIndex: 0, commandId };
  renderPalette(items, 0);
};

// 管理APIで設定を更新する。
const applyAdminUpdate = (commandId, value) => {
  const api = requireAdminApi();
  const payload = { [commandId]: value };
  return api.updateAdminConfig(payload).then((updated) => {
    adminConfig = updated;
  });
};

// 初期化はfail-fastで行う（欠落や不整合は即停止）。
try {
  startUi();
  setupTerminal();
  loadConsoleConfig()
    .then((data) => {
      applyConsoleConfig(data);
      inputEl.disabled = false;
      inputEl.focus();
      // Missionペイン・Inspectorペイン・Vitalsペインを初期化
      updateMissionPane();
      updateInspectorPane();
      updateVitalsPane();
      // 起動時に現在の状態に応じたプロンプトを再表示
      const api = requireSpectraApi();
      api.getState().then((state) => {
        const purpose = state?.mission?.purpose;
        const judgment = state?.thought?.judgment;
        const action = state?.action;
        const avatarName = data?.avatar?.name || 'SPECTRA';

        // 承認待ち → 承認プロンプトを再表示
        if (action?.phase === 'approving' && action?.command) {
          requestApproval('__terminal__', action.command, action.summary || action.command);
          return;
        }

        // 継続待ち → [Enter] で続行を再表示
        if (action?.phase === 'awaiting_continue') {
          pendingContinue = { label: action.summary || 'タスク完了' };
          addLine('text-line--system', `> ${pendingContinue.label} [Enter] で続行`);
          return;
        }

        // 目的確認待ち → 確認プロンプトを再表示
        if (action?.phase === 'awaiting_purpose_confirm') {
          addLine('text-line--avatar', `${avatarName}> 全ての目標が完了しました。目的「${purpose}」は達成されましたか？`);
          addLine('text-line--avatar', `${avatarName}> [y] 達成 / [n] 続行 / 新しい目的を入力`);
          return;
        }

        // purpose未設定 → 問いかけを表示
        if (!purpose && judgment === 'purpose未設定') {
          addLine('text-line--avatar', `${avatarName}> 目的が設定されていません。何を達成しましょうか？`);
        }
      }).catch(() => {});
      // イベントポーリング開始（3秒間隔）
      setInterval(pollEvents, 3000);
      pollEvents();
    })
    .catch((error) => {
      failFast(error instanceof Error ? error.message : String(error));
    });
} catch (error) {
  failFast(error instanceof Error ? error.message : String(error));
}

// Enter入力でCore APIへ送信し、応答を表示する。
if (inputEl) {
  let isRunning = false;

  // コマンド候補の選択を確定する。
  const confirmPaletteSelection = () => {
    if (!commandState) {
      return;
    }
    const { items, activeIndex, type } = commandState;
    const item = items?.[activeIndex];
    if (!item) {
      resetCommandState();
      return;
    }
    if (type === 'commands') {
      openCommandOptions(item.commandId);
      return;
    }
    if (type === 'options') {
      const label = `${item.commandId}=${item.label}`;
      applyAdminUpdate(item.commandId, item.value)
        .then(() => {
          resetCommandState();
          inputEl.value = '';
          inputEl.focus();
          addLine('text-line--system', `> updated ${item.commandId}`);
        })
        .catch((error) => {
          failFast(error instanceof Error ? error.message : String(error));
        });
    }
  };

  // コマンド候補の選択位置を変更する。
  const movePaletteSelection = (direction) => {
    if (!commandState || !commandState.items) {
      return;
    }
    const total = commandState.items.length;
    if (total === 0) {
      return;
    }
    let nextIndex = commandState.activeIndex + direction;
    if (nextIndex < 0) {
      nextIndex = total - 1;
    }
    if (nextIndex >= total) {
      nextIndex = 0;
    }
    commandState.activeIndex = nextIndex;
    renderPalette(commandState.items, nextIndex);
  };

  // コマンドの値入力を確定する。
  const confirmValueInput = () => {
    if (!commandState || commandState.type !== 'value') {
      return false;
    }
    const value = inputEl.value.trim();
    if (!value) {
      failFast('Command value is missing.');
    }
    applyAdminUpdate(commandState.commandId, value)
      .then(() => {
        resetCommandState();
        inputEl.value = '';
        inputEl.focus();
        addLine('text-line--system', `> updated ${commandState.commandId}`);
      })
      .catch((error) => {
        failFast(error instanceof Error ? error.message : String(error));
      });
    return true;
  };

  inputEl.addEventListener('keydown', (event) => {
    if (event.isComposing || event.key !== 'Enter') {
      return;
    }
    event.preventDefault();

    if (handleApprovalInput()) {
      return;
    }

    if (commandState?.type === 'value') {
      confirmValueInput();
      return;
    }

    if (commandState?.type === 'commands' || commandState?.type === 'options') {
      confirmPaletteSelection();
      return;
    }

    if (isRunning) {
      return;
    }

    const value = inputEl.value.trim();
    if (!value) {
      // 空入力時: awaiting_continue なら続行
      handleEmptyContinue();
      return;
    }

    if (value.startsWith('/')) {
      openCommandPalette(value.slice(1));
      return;
    }

    if (!consoleConfig?.name_tags?.user) {
      failFast('console_ui.name_tags.user is missing.');
    }
    addLine('text-line--user', `${consoleConfig.name_tags.user}> ${value}`);
    inputEl.value = '';

    setTalking(true);
    isRunning = true;
    inputEl.disabled = true;

    // preloadで公開されたAPIが無ければエラー表示。
    const api = requireSpectraApi();
    if (!api.think) {
      failFast('Core API is unavailable.');
    }

    api.think({ source: 'dialogue', text: value, sessionId })
      .then((data) => {
        if (!data?.response) {
          failFast('Core response is missing.');
        }
        if (data.intent === 'action' && data.proposal?.command) {
          const label = data.proposal.summary || data.proposal.command;
          requestApproval('__terminal__', data.proposal.command, label);
          return;
        }
        const avatarName = consoleConfig?.name_tags?.avatar || 'SPECTRA';
        addLine('text-line--assistant', `${avatarName}> ${data.response}`);
      })
      .catch((error) => {
        failFast(error instanceof Error ? error.message : String(error));
      })
      .finally(() => {
        setTalking(false);
        if (!isFatal) {
          inputEl.disabled = false;
          inputEl.focus();
        }
        isRunning = false;
        // Missionペイン・Inspectorペインを更新
        updateMissionPane();
        updateInspectorPane();
      });
  });

  // 入力内容に応じてコマンド候補を出す。
  inputEl.addEventListener('input', () => {
    if (commandState?.type === 'value') {
      return;
    }
    const value = inputEl.value.trim();
    if (!value.startsWith('/')) {
      resetCommandState();
      return;
    }
    openCommandPalette(value.slice(1));
  });

  // 候補欄のクリックで選択する。
  commandPaletteEl.addEventListener('click', (event) => {
    const item = event.target.closest('.command-item');
    if (!item || !commandState) {
      return;
    }
    const index = Array.from(commandPaletteEl.children).indexOf(item);
    if (index < 0) {
      return;
    }
    commandState.activeIndex = index;
    confirmPaletteSelection();
  });

  // 矢印キーとESCで候補を操作する。
  inputEl.addEventListener('keydown', (event) => {
    if (!commandState || commandState.type === 'value') {
      return;
    }
    if (event.key === 'ArrowDown') {
      event.preventDefault();
      movePaletteSelection(1);
    }
    if (event.key === 'ArrowUp') {
      event.preventDefault();
      movePaletteSelection(-1);
    }
    if (event.key === 'Escape') {
      event.preventDefault();
      resetCommandState();
      inputEl.placeholder = '';
    }
  });
}

// --- スプリッター（リサイズハンドル）処理 ---
// ペイン間の境界をドラッグしてサイズ調整する。
(() => {
  const root = document.documentElement;
  const paneRight = document.getElementById('pane-right');
  const splitterMain = document.getElementById('splitter-main');
  const surfaceHost = document.getElementById('surface-host');

  if (!splitterMain || !paneRight || !surfaceHost) {
    return;
  }

  // 左右パネル間のスプリッター
  let isDraggingMain = false;

  splitterMain.addEventListener('mousedown', (e) => {
    e.preventDefault();
    isDraggingMain = true;
    splitterMain.classList.add('is-dragging');
    document.body.classList.add('is-resizing');
  });

  document.addEventListener('mousemove', (e) => {
    if (!isDraggingMain) {
      return;
    }
    // 右パネル幅 = ウィンドウ右端 - マウスX座標 - 余白
    const appRect = document.querySelector('.app').getBoundingClientRect();
    const newWidth = appRect.right - e.clientX - 20;
    const clamped = Math.max(120, Math.min(400, newWidth));
    root.style.setProperty('--right-panel-width', `${clamped}px`);
  });

  document.addEventListener('mouseup', () => {
    if (isDraggingMain) {
      isDraggingMain = false;
      splitterMain.classList.remove('is-dragging');
      document.body.classList.remove('is-resizing');
    }
  });

  // 垂直スプリッター（surface間）
  const verticalSplitters = surfaceHost.querySelectorAll('.splitter--vertical');

  verticalSplitters.forEach((splitter) => {
    let isDragging = false;
    let prevSurface = null;

    splitter.addEventListener('mousedown', (e) => {
      e.preventDefault();
      isDragging = true;
      prevSurface = splitter.previousElementSibling;
      splitter.classList.add('is-dragging');
      document.body.classList.add('is-resizing', 'is-resizing-vertical');
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging || !prevSurface) {
        return;
      }
      const hostRect = surfaceHost.getBoundingClientRect();
      const surfaceRect = prevSurface.getBoundingClientRect();
      // 上surfaceの高さ = マウスY - surface上端
      const newHeight = e.clientY - surfaceRect.top;
      const minH = 60;
      const maxH = hostRect.height * 0.7;
      const clamped = Math.max(minH, Math.min(maxH, newHeight));
      prevSurface.style.flex = 'none';
      prevSurface.style.height = `${clamped}px`;
    });

    document.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        splitter.classList.remove('is-dragging');
        document.body.classList.remove('is-resizing', 'is-resizing-vertical');
        prevSurface = null;
      }
    });
  });
})();
