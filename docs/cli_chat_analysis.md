# CLIとチャットの役割設計（メタ認知コア前提）

## 前提
- 単一のコアが状況を判断し、チャットとCLIを臨機応変に使い分ける。
- どちらも「同じ正本（Core）」に繋がっている。
- 承認が必要な操作は必ず人間が決定する。

## 目的
- チャットとCLIの役割を「限界」から逆算して設計する。
- 冗長な機能を排除し、運用の最短経路を作る。
- 事故リスクを下げつつ、運用速度を上げる。

---

## 1. 使い分けの原則（メタ認知ルール）

### 1.1 チャットが適切な条件
- 意図の確認や承認が必要。
- 結果が短く、人間の理解が主目的。
- 変更理由や背景説明が必要。
- 作業の意味が運用に影響する。

### 1.2 CLIが適切な条件
- 入出力が多い（長文・大量データ）。
- 再現性やスクリプト化が重要。
- 正確さが最優先（誤解が許されない）。
- 低レベルの調査や検証が必要。

### 1.3 競合時の優先順位
1. 安全性（誤操作の可能性が高いならチャット+承認）
2. 正確性（手順や値が厳密ならCLI）
3. 速度（単純な設定変更ならチャット）

---

## 2. チャットとCLIの限界（詳細）

### 2.1 チャットの限界
- 自然言語は曖昧で、誤解が起きる。
- 差分・履歴・大量出力の把握が弱い。
- 同じ操作を繰り返すと手間が増える。
- 設定値の厳密さを担保しにくい。

### 2.2 CLIの限界
- 学習コストがある。
- 承認や理由の説明が弱い。
- 変更意図が伝わりにくい。
- 初心者にとって敷居が高い。

---

## 3. 具体的なユースケースの分類

### 3.1 チャットに寄せるべき操作
- モデル/温度/システムプロンプトの変更
- チャネルのON/OFF
- タスクの追加/停止/再開（人間承認付き）
- 現在の設定の簡易確認
- 失敗理由の要約説明
 - `/` コマンドによる設定変更や状態確認

### 3.2 CLIに寄せるべき操作
- 大量ログの検索やフィルタ
- 設定ファイル（YAML/ENV）の直接編集
- 同じ操作の繰り返し（バッチ）
- 低レベルの疎通テスト（curl等）
- デバッグ用の詳細ログ確認

### 3.3 どちらでも可能だが分ける理由がある操作
- タスク一覧: チャットは要約、CLIは詳細
- 設定変更: チャットは承認、CLIは一括更新
- エラー確認: チャットは説明、CLIは実データ

---

## 3.4 `/` コマンドの位置づけ

### 役割
- チャット内で「明確な操作」を指定するための固定フォーマット。
- 自然文の曖昧さを避け、最小の実装で安全に操作する。

### 向いている操作
- 単一の値を変更する操作（温度、モデルなど）
- 設定の現在値を取得する操作
- 状態の切り替え（ON/OFF）

### 向いていない操作
- 大量出力（ログ、一覧の全件表示）
- 複雑な条件を伴う操作
- 一括更新や繰り返し処理

### ルール
- `/` コマンドは **承認前提** とする。
- 実行結果は **短い要約** を返す。
- 詳細はCLIで確認する。

---

## 4. 単一コアでの制御フロー

### 4.1 コアの判断プロセス
1. 指示内容を分類する（変更/調査/実行）
2. 安全性・正確性・量で分岐
3. チャット or CLI を選択
4. 承認が必要なら必ず停止して待つ

### 4.2 実行ルール
- 変更系は「必ず承認」
- 調査系は「チャット要約 + CLI詳細」
- 実行系は「CLIを優先」

---

## 5. 最小構成の実装方針（現実解）

### 5.1 共通APIを正本にする
- チャットもCLIも同じAPIを使う。
- 片方だけに機能を持たせない。

### 5.2 チャットの役割を明確化
- コマンドパレット（固定フォーマット）
- 承認UI（1クリック）
- 変更結果の要約

### 5.3 CLIの役割を明確化
- 詳細ログと検証
- 大量データの調査
- 実行の自動化（スクリプト化）

---

## 6. 失敗を減らす運用ルール

- 変更は「人間が承認してから反映」
- 変更結果はチャットで要約を返す
- CLIは詳細記録のために残す
- 失敗時はチャットで原因説明、CLIで詳細確認

---

## 7. まとめ

- チャットは「意図と承認」、CLIは「詳細と正確さ」。
- 単一コアが状況を見て最短経路を選ぶ。
- 役割を分けることで、UXと安全性が両立できる。
